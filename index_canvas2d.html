<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cloth - Canvas2D</title>
  <style>
    html,body{margin:0;height:100%;background:#fff;overflow:hidden}
    canvas{display:block}
    #hud{position:fixed;left:10px;top:10px;font:12px/1.2 system-ui;color:#000}
  </style>
</head>
<body>
  <div id="hud">Canvas2D • 256×256 • red tris + blue wire • white bg</div>
  <canvas id="c"></canvas>

  <script type="module">
    import { Cloth } from "./cloth.js";

    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:false });

    function resize(){
      canvas.width = innerWidth * devicePixelRatio;
      canvas.height = innerHeight * devicePixelRatio;
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    addEventListener("resize", resize);
    resize();

    // Simple camera + perspective projection
    const camPos = { x: 0, y: 1.2, z: 2.2 };
    const target = { x: 0, y: 0.2, z: 0 };
    const fov = 55 * Math.PI/180;

    function normalize(v){
      const l = Math.hypot(v.x,v.y,v.z)||1;
      v.x/=l; v.y/=l; v.z/=l; return v;
    }
    function cross(a,b){
      return { x: a.y*b.z - a.z*b.y, y: a.z*b.x - a.x*b.z, z: a.x*b.y - a.y*b.x };
    }
    function sub(a,b){ return { x:a.x-b.x, y:a.y-b.y, z:a.z-b.z }; }

    function makeViewBasis(){
      const f = normalize(sub(target, camPos));         // forward
      const up = { x:0, y:1, z:0 };
      const r = normalize(cross(f, up));                // right
      const u = cross(r, f);                            // true up
      return { r, u, f };
    }

    function project(x,y,z, basis){
      // world -> camera
      const dx = x - camPos.x, dy = y - camPos.y, dz = z - camPos.z;
      const cx = dx*basis.r.x + dy*basis.r.y + dz*basis.r.z;
      const cy = dx*basis.u.x + dy*basis.u.y + dz*basis.u.z;
      const cz = dx*(-basis.f.x) + dy*(-basis.f.y) + dz*(-basis.f.z); // camera forward is -Z

      // perspective
      const h = innerHeight;
      const s = (0.5 * h) / Math.tan(fov * 0.5);
      if (cz <= 0.01) return null;
      const sx = (innerWidth*0.5) + (cx * s / cz);
      const sy = (innerHeight*0.5) - (cy * s / cz);
      return { x:sx, y:sy, z:cz };
    }

    const cloth = new Cloth({
      nx: 256, ny: 256,
      spacing: 0.01,
      origin: [-1.28, 0.7, -1.28],
      pinEdge: "top",
      constraintIters: 6,
      useShear: true,
    });

    const pos = cloth.getPositions();
    const tri = cloth.getTriangleIndices();
    const lines = cloth.getLineIndices();

    let last = performance.now();
    function frame(t){
      const dt = (t - last)/1000; last = t;
      cloth.step(dt);

      ctx.clearRect(0,0,innerWidth,innerHeight);

      const basis = makeViewBasis();

      // Project all vertices once (big speed win)
      const n = pos.length/3;
      const P = new Array(n);
      for (let i=0;i<n;i++){
        const p3 = i*3;
        P[i] = project(pos[p3], pos[p3+1], pos[p3+2], basis);
      }

      // Fill triangles (red)
      ctx.fillStyle = "#ff0000";
      for (let k=0;k<tri.length;k+=3){
        const a = P[tri[k]], b = P[tri[k+1]], c = P[tri[k+2]];
        if (!a || !b || !c) continue;
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.lineTo(c.x,c.y);
        ctx.closePath();
        ctx.fill();
      }

      // Wireframe (blue)
      ctx.strokeStyle = "#0000ff";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let k=0;k<lines.length;k+=2){
        const a = P[lines[k]], b = P[lines[k+1]];
        if (!a || !b) continue;
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
      }
      ctx.stroke();

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  </script>
</body>
</html>
