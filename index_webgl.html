<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cloth - WebGL</title>
  <style>
    html,body{margin:0;height:100%;background:#fff;overflow:hidden}
    canvas{display:block}
    #hud{position:fixed;left:10px;top:10px;font:12px/1.2 system-ui;color:#000}
  </style>
</head>
<body>
  <div id="hud">WebGL • 256×256 • red tris + blue lines • white bg</div>
  <canvas id="gl"></canvas>

  <script type="module">
    import { Cloth } from "./cloth.js";

    const canvas = document.getElementById("gl");
    const gl = canvas.getContext("webgl", { antialias:true, alpha:false });
    if (!gl) throw new Error("WebGL not supported");

    function resize(){
      const dpr = devicePixelRatio || 1;
      canvas.width = Math.floor(innerWidth*dpr);
      canvas.height = Math.floor(innerHeight*dpr);
      canvas.style.width = innerWidth+"px";
      canvas.style.height = innerHeight+"px";
      gl.viewport(0,0,canvas.width,canvas.height);
    }
    addEventListener("resize", resize);
    resize();

    gl.clearColor(1,1,1,1);
    gl.enable(gl.DEPTH_TEST);

    const vsSrc = `
      attribute vec3 aPos;
      uniform mat4 uMVP;
      void main(){
        gl_Position = uMVP * vec4(aPos, 1.0);
      }
    `;
    const fsSrc = `
      precision mediump float;
      uniform vec4 uColor;
      void main(){
        gl_FragColor = uColor;
      }
    `;

    function compile(type, src){
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(s) || "shader compile failed");
      }
      return s;
    }
    const prog = gl.createProgram();
    gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      throw new Error(gl.getProgramInfoLog(prog) || "program link failed");
    }
    gl.useProgram(prog);

    const aPos = gl.getAttribLocation(prog, "aPos");
    const uMVP = gl.getUniformLocation(prog, "uMVP");
    const uColor = gl.getUniformLocation(prog, "uColor");

    // Minimal mat4 utils (column-major)
    function mat4Identity(){
      return new Float32Array([1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1]);
    }
    function mat4Mul(a,b){
      const o = new Float32Array(16);
      for (let c=0;c<4;c++){
        for (let r=0;r<4;r++){
          o[c*4+r] =
            a[0*4+r]*b[c*4+0] +
            a[1*4+r]*b[c*4+1] +
            a[2*4+r]*b[c*4+2] +
            a[3*4+r]*b[c*4+3];
        }
      }
      return o;
    }
    function mat4Perspective(fovy, aspect, near, far){
      const f = 1/Math.tan(fovy/2);
      const nf = 1/(near - far);
      return new Float32Array([
        f/aspect,0,0,0,
        0,f,0,0,
        0,0,(far+near)*nf,-1,
        0,0,(2*far*near)*nf,0
      ]);
    }
    function vec3Normalize(x,y,z){
      const l = Math.hypot(x,y,z)||1;
      return [x/l,y/l,z/l];
    }
    function vec3Cross(ax,ay,az,bx,by,bz){
      return [ay*bz-az*by, az*bx-ax*bz, ax*by-ay*bx];
    }
    function mat4LookAt(eye, center, up){
      let zx = eye[0]-center[0], zy = eye[1]-center[1], zz = eye[2]-center[2];
      [zx,zy,zz] = vec3Normalize(zx,zy,zz);
      let xx,xy,xz;
      [xx,xy,xz] = vec3Cross(up[0],up[1],up[2], zx,zy,zz);
      [xx,xy,xz] = vec3Normalize(xx,xy,xz);
      let yx,yy,yz;
      [yx,yy,yz] = vec3Cross(zx,zy,zz, xx,xy,xz);

      return new Float32Array([
        xx, yx, zx, 0,
        xy, yy, zy, 0,
        xz, yz, zz, 0,
        -(xx*eye[0]+xy*eye[1]+xz*eye[2]),
        -(yx*eye[0]+yy*eye[1]+yz*eye[2]),
        -(zx*eye[0]+zy*eye[1]+zz*eye[2]),
        1
      ]);
    }

    const cloth = new Cloth({
      nx: 256, ny: 256,
      spacing: 0.01,
      origin: [-1.28, 0.7, -1.28],
      pinEdge: "top",
      constraintIters: 6,
      useShear: true,
    });

    const positions = cloth.getPositions();
    const triIdx = cloth.getTriangleIndices();
    const lineIdx = cloth.getLineIndices();

    // VBO (dynamic)
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

    // IBO for triangles
    const iboTri = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTri);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, triIdx, gl.STATIC_DRAW);

    // IBO for lines
    const iboLine = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLine);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineIdx, gl.STATIC_DRAW);

    let last = performance.now();
    function render(t){
      const dt = Math.min((t-last)/1000, 1/30); last = t;
      cloth.step(dt);

      // Update positions
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, positions);

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const aspect = canvas.width / canvas.height;
      const P = mat4Perspective(55*Math.PI/180, aspect, 0.01, 100);
      const V = mat4LookAt([0,1.2,2.2], [0,0.2,0], [0,1,0]);
      const M = mat4Identity();
      const MVP = mat4Mul(P, mat4Mul(V, M));
      gl.uniformMatrix4fv(uMVP, false, MVP);

      // Draw triangles (red)
      gl.uniform4f(uColor, 1,0,0,1);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTri);
      gl.drawElements(gl.TRIANGLES, triIdx.length, gl.UNSIGNED_INT, 0);

      // Draw wire lines (blue)
      gl.uniform4f(uColor, 0,0,1,1);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLine);
      gl.drawElements(gl.LINES, lineIdx.length, gl.UNSIGNED_INT, 0);

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>
