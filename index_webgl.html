<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cloth Demo – Raw WebGL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #ffffff;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #hud {
      position: fixed;
      left: 10px;
      top: 10px;
      font: 12px system-ui, sans-serif;
      color: #000;
      background: rgba(255,255,255,0.85);
      padding: 6px 8px;
      border: 1px solid #000;
    }
  </style>
</head>
<body>
  <div id="hud">
    WebGL (Safari-safe)<br/>
    Grab: drag<br/>
    Wind: Shift+drag<br/>
    Toggle wind: W
  </div>
  <canvas id="gl"></canvas>

<script type="module">
import { Cloth } from "./cloth.js";

/* ------------------------------------------------------------------ */
/* Canvas + GL setup                                                   */
/* ------------------------------------------------------------------ */

const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl", { alpha: false, antialias: true });
if (!gl) {
  alert("WebGL not supported");
  throw new Error("WebGL not supported");
}

function resize() {
  const dpr = devicePixelRatio || 1;
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  gl.viewport(0, 0, canvas.width, canvas.height);
}
addEventListener("resize", resize);
resize();

gl.clearColor(1, 1, 1, 1);
gl.enable(gl.DEPTH_TEST);

/* ------------------------------------------------------------------ */
/* Shaders                                                            */
/* ------------------------------------------------------------------ */

const VS = `
attribute vec3 aPos;
uniform mat4 uMVP;
void main() {
  gl_Position = uMVP * vec4(aPos, 1.0);
}
`;

const FS = `
precision mediump float;
uniform vec4 uColor;
void main() {
  gl_FragColor = uColor;
}
`;

function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(s));
  }
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, VS));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FS));
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
  throw new Error(gl.getProgramInfoLog(prog));
}
gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog, "aPos");
const uMVP = gl.getUniformLocation(prog, "uMVP");
const uColor = gl.getUniformLocation(prog, "uColor");

/* ------------------------------------------------------------------ */
/* Minimal math                                                        */
/* ------------------------------------------------------------------ */

function perspective(fovy, aspect, near, far) {
  const f = 1 / Math.tan(fovy / 2);
  const nf = 1 / (near - far);
  return new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * far * near) * nf, 0
  ]);
}

function lookAt(eye, target, up) {
  let zx = eye[0] - target[0],
      zy = eye[1] - target[1],
      zz = eye[2] - target[2];
  const zl = Math.hypot(zx, zy, zz) || 1;
  zx /= zl; zy /= zl; zz /= zl;

  let xx = up[1]*zz - up[2]*zy,
      xy = up[2]*zx - up[0]*zz,
      xz = up[0]*zy - up[1]*zx;
  const xl = Math.hypot(xx, xy, xz) || 1;
  xx /= xl; xy /= xl; xz /= xl;

  const yx = zy*xz - zz*xy,
        yy = zz*xx - zx*xz,
        yz = zx*xy - zy*xx;

  return new Float32Array([
    xx, yx, zx, 0,
    xy, yy, zy, 0,
    xz, yz, zz, 0,
    -(xx*eye[0] + xy*eye[1] + xz*eye[2]),
    -(yx*eye[0] + yy*eye[1] + yz*eye[2]),
    -(zx*eye[0] + zy*eye[1] + zz*eye[2]),
    1
  ]);
}

function mul(a, b) {
  const o = new Float32Array(16);
  for (let c = 0; c < 4; c++) {
    for (let r = 0; r < 4; r++) {
      o[c*4 + r] =
        a[0*4 + r] * b[c*4 + 0] +
        a[1*4 + r] * b[c*4 + 1] +
        a[2*4 + r] * b[c*4 + 2] +
        a[3*4 + r] * b[c*4 + 3];
    }
  }
  return o;
}

/* ------------------------------------------------------------------ */
/* Cloth (Safari-safe size)                                            */
/* ------------------------------------------------------------------ */

const cloth = new Cloth({
  nx: 128,
  ny: 128,
  spacing: 0.02,
  origin: [-1.28, 0.7, -1.28],
  pinEdge: "top",
  constraintIters: 6,
  useShear: true
});

const positions = cloth.getPositions();

/* IMPORTANT: Uint16 indices only */
const triIdx = new Uint16Array(cloth.getTriangleIndices());
const lineIdx = new Uint16Array(cloth.getLineIndices());

/* ------------------------------------------------------------------ */
/* Buffers                                                            */
/* ------------------------------------------------------------------ */

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

const iboTri = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTri);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, triIdx, gl.STATIC_DRAW);

const iboLine = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLine);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineIdx, gl.STATIC_DRAW);

/* ------------------------------------------------------------------ */
/* Pointer → ray                                                       */
/* ------------------------------------------------------------------ */

const camEye = [0, 1.2, 2.2];
const camTarget = [0, 0.2, 0];
const camUp = [0, 1, 0];
const fov = 55 * Math.PI / 180;

const pointer = { x: 0, y: 0, down: false, shift: false, lx: 0, ly: 0 };

addEventListener("pointermove", e => {
  pointer.x = e.clientX;
  pointer.y = e.clientY;
  pointer.shift = e.shiftKey;

  if (pointer.down && pointer.shift) {
    const dx = e.clientX - pointer.lx;
    const dy = e.clientY - pointer.ly;
    cloth.setWind([dx * 0.02, 0, dy * 0.02]);
  }
  pointer.lx = e.clientX;
  pointer.ly = e.clientY;
});

addEventListener("pointerdown", e => {
  pointer.down = true;
  pointer.shift = e.shiftKey;
  pointer.lx = e.clientX;
  pointer.ly = e.clientY;
});

addEventListener("pointerup", () => pointer.down = false);
addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "w") {
    cloth.setWindEnabled(!cloth.windEnabled);
  }
});

function screenRay() {
  const nx = (pointer.x / innerWidth) * 2 - 1;
  const ny = -(pointer.y / innerHeight) * 2 + 1;
  const aspect = canvas.width / canvas.height;
  const t = Math.tan(fov * 0.5);

  let dx = nx * t * aspect;
  let dy = ny * t;
  let dz = -1;
  const l = Math.hypot(dx, dy, dz) || 1;
  dx /= l; dy /= l; dz /= l;

  // forward
  let fx = camTarget[0] - camEye[0],
      fy = camTarget[1] - camEye[1],
      fz = camTarget[2] - camEye[2];
  const fl = Math.hypot(fx, fy, fz) || 1;
  fx /= fl; fy /= fl; fz /= fl;

  // right
  let rx = fy * camUp[2] - fz * camUp[1],
      ry = fz * camUp[0] - fx * camUp[2],
      rz = fx * camUp[1] - fy * camUp[0];
  const rl = Math.hypot(rx, ry, rz) || 1;
  rx /= rl; ry /= rl; rz /= rl;

  // up
  const ux = ry * fz - rz * fy,
        uy = rz * fx - rx * fz,
        uz = rx * fy - ry * fx;

  const wx = rx * dx + ux * dy + fx * (-dz);
  const wy = ry * dx + uy * dy + fy * (-dz);
  const wz = rz * dx + uz * dy + fz * (-dz);
  const wl = Math.hypot(wx, wy, wz) || 1;

  return { o: camEye, d: [wx/wl, wy/wl, wz/wl] };
}

/* ------------------------------------------------------------------ */
/* Loop                                                               */
/* ------------------------------------------------------------------ */

let last = performance.now();
function frame(t) {
  const dt = Math.min((t - last) / 1000, 1/30);
  last = t;

  const ray = screenRay();
  cloth.setPointerRay(ray.o, ray.d, pointer.down);
  cloth.step(dt);

  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, positions);

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const P = perspective(fov, canvas.width / canvas.height, 0.01, 100);
  const V = lookAt(camEye, camTarget, camUp);
  const MVP = mul(P, V);
  gl.uniformMatrix4fv(uMVP, false, MVP);

  gl.uniform4f(uColor, 1, 0, 0, 1);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTri);
  gl.drawElements(gl.TRIANGLES, triIdx.length, gl.UNSIGNED_SHORT, 0);

  gl.uniform4f(uColor, 0, 0, 1, 1);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLine);
  gl.drawElements(gl.LINES, lineIdx.length, gl.UNSIGNED_SHORT, 0);

  requestAnimationFrame(frame);
}

requestAnimationFrame(frame);
</script>
</body>
</html>
